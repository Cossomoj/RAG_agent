
РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Java Developer; ТЕМА: Основы лучших практик Java разработки

# Лучшие практики Java разработки для специалиста

## Введение в лучшие практики

### Определение лучших практик:
Лучшие практики Java разработки — это проверенные временем подходы, принципы и рекомендации, которые помогают писать качественный, поддерживаемый и эффективный код.

### Важность следования лучшим практикам:
- **Читаемость кода**: Понятность для других разработчиков
- **Поддерживаемость**: Легкость внесения изменений
- **Производительность**: Оптимальная работа приложений
- **Безопасность**: Защита от уязвимостей
- **Масштабируемость**: Возможность роста системы

### Основные принципы:
1. **SOLID принципы**: Основа объектно-ориентированного программирования
2. **DRY (Don't Repeat Yourself)**: Избежание дублирования кода
3. **KISS (Keep It Simple, Stupid)**: Простота решений
4. **YAGNI (You Aren't Gonna Need It)**: Не добавлять функциональность заранее

## Принципы SOLID

### Single Responsibility Principle (SRP):
**Класс должен иметь только одну причину для изменения**

#### Пример нарушения:
```java
public class UserService {
    public void createUser(User user) { /* создание пользователя */ }
    public void sendEmail(String to, String subject) { /* отправка email */ }
    public void generateReport() { /* генерация отчета */ }
}
```

#### Правильная реализация:
```java
public class UserService {
    public void createUser(User user) { /* создание пользователя */ }
}

public class EmailService {
    public void sendEmail(String to, String subject) { /* отправка email */ }
}

public class ReportService {
    public void generateReport() { /* генерация отчета */ }
}
```

### Open/Closed Principle (OCP):
**Программные сущности должны быть открыты для расширения, но закрыты для модификации**

#### Пример:
```java
public interface PaymentProcessor {
    void processPayment(Payment payment);
}

public class CreditCardProcessor implements PaymentProcessor {
    public void processPayment(Payment payment) { /* обработка картой */ }
}

public class PayPalProcessor implements PaymentProcessor {
    public void processPayment(Payment payment) { /* обработка PayPal */ }
}
```


РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Java Developer; ТЕМА: Чистый код и соглашения по именованию

## Чистый код и соглашения по именованию

### Принципы чистого кода:

#### 1. Осмысленные имена
- **Переменные**: Описывают что содержат
- **Методы**: Описывают что делают
- **Классы**: Описывают что представляют

#### Примеры хороших имен:
```java
// Плохо
int d; // время в днях
List<Data> l; // список пользователей

// Хорошо
int daysSinceCreation;
List<User> activeUsers;
```

#### 2. Функции должны быть маленькими
- **Максимум 20 строк**
- **Одна функция — одна задача**
- **Понятные имена функций**

#### Пример рефакторинга:
```java
// Плохо
public void processOrder(Order order) {
    if (order != null && order.getItems() != null && !order.getItems().isEmpty()) {
        for (Item item : order.getItems()) {
            if (item.getPrice() > 0) {
                // 50+ строк логики
            }
        }
    }
}

// Хорошо
public void processOrder(Order order) {
    if (!isValidOrder(order)) {
        return;
    }
    
    for (Item item : order.getItems()) {
        processItem(item);
    }
}

private boolean isValidOrder(Order order) {
    return order != null && order.getItems() != null && !order.getItems().isEmpty();
}

private void processItem(Item item) {
    if (item.getPrice() > 0) {
        // логика обработки
    }
}
```

### Соглашения по именованию в Java:

#### Классы и интерфейсы:
- **PascalCase**: `UserService`, `PaymentProcessor`
- **Существительные**: `User`, `Order`, `EmailService`

#### Методы и переменные:
- **camelCase**: `getUserById()`, `calculateTotal()`
- **Глаголы для методов**: `create`, `update`, `delete`, `calculate`

#### Константы:
- **UPPER_SNAKE_CASE**: `MAX_RETRY_ATTEMPTS`, `DEFAULT_TIMEOUT`

#### Пакеты:
- **lowercase**: `com.company.project.service`


РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Java Developer; ТЕМА: Паттерны проектирования в Java

## Паттерны проектирования в Java

### Классификация паттернов:

#### 1. Порождающие паттерны (Creational Patterns)

##### Singleton (Одиночка):
```java
public class DatabaseConnection {
    private static DatabaseConnection instance;
    private DatabaseConnection() {}
    
    public static synchronized DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
```

##### Factory Method (Фабричный метод):
```java
public interface PaymentProcessor {
    void processPayment(Payment payment);
}

public class PaymentProcessorFactory {
    public static PaymentProcessor createProcessor(String type) {
        switch (type) {
            case "CREDIT_CARD":
                return new CreditCardProcessor();
            case "PAYPAL":
                return new PayPalProcessor();
            default:
                throw new IllegalArgumentException("Unknown processor type");
        }
    }
}
```

##### Builder (Строитель):
```java
public class User {
    private String name;
    private String email;
    private int age;
    
    public static class Builder {
        private User user = new User();
        
        public Builder name(String name) {
            user.name = name;
            return this;
        }
        
        public Builder email(String email) {
            user.email = email;
            return this;
        }
        
        public Builder age(int age) {
            user.age = age;
            return this;
        }
        
        public User build() {
            return user;
        }
    }
}

// Использование
User user = new User.Builder()
    .name("John")
    .email("john@example.com")
    .age(30)
    .build();
```

#### 2. Структурные паттерны (Structural Patterns)

##### Adapter (Адаптер):
```java
public interface PaymentGateway {
    void processPayment(double amount);
}

public class LegacyPaymentSystem {
    public void pay(double amount) {
        // старая логика
    }
}

public class PaymentAdapter implements PaymentGateway {
    private LegacyPaymentSystem legacySystem;
    
    public PaymentAdapter(LegacyPaymentSystem legacySystem) {
        this.legacySystem = legacySystem;
    }
    
    public void processPayment(double amount) {
        legacySystem.pay(amount);
    }
}
```


РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Java Developer; ТЕМА: Оптимизация производительности Java приложений

## Оптимизация производительности Java приложений

### Основные принципы оптимизации:

#### 1. Управление памятью
- **Избежание утечек памяти**: Правильное закрытие ресурсов
- **Использование пулов объектов**: Для часто создаваемых объектов
- **Оптимизация коллекций**: Выбор подходящих структур данных

#### Пример оптимизации коллекций:
```java
// Плохо - O(n) поиск
List<String> names = new ArrayList<>();
for (String name : names) {
    if (name.equals("target")) {
        // найдено
    }
}

// Хорошо - O(1) поиск
Set<String> names = new HashSet<>();
if (names.contains("target")) {
    // найдено
}
```

#### 2. Строки и их оптимизация
```java
// Плохо - создается много объектов
String result = "";
for (int i = 0; i < 1000; i++) {
    result += "item" + i;
}

// Хорошо - StringBuilder
StringBuilder result = new StringBuilder();
for (int i = 0; i < 1000; i++) {
    result.append("item").append(i);
}
String finalResult = result.toString();
```

#### 3. Многопоточность и производительность
```java
// Использование ExecutorService
ExecutorService executor = Executors.newFixedThreadPool(10);
List<Future<String>> futures = new ArrayList<>();

for (String task : tasks) {
    futures.add(executor.submit(() -> processTask(task)));
}

// Ожидание завершения всех задач
for (Future<String> future : futures) {
    String result = future.get();
    // обработка результата
}
```

### Профилирование и мониторинг:

#### Инструменты профилирования:
- **JProfiler**: Коммерческий профилировщик
- **VisualVM**: Бесплатный инструмент из JDK
- **YourKit**: Профессиональный профилировщик
- **JConsole**: Мониторинг JVM

#### Ключевые метрики:
- **Heap usage**: Использование кучи
- **GC time**: Время сборки мусора
- **CPU usage**: Использование процессора
- **Thread count**: Количество потоков


РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Java Developer; ТЕМА: Безопасность в Java приложениях

## Безопасность в Java приложениях

### Основные принципы безопасности:

#### 1. Валидация входных данных
```java
// Плохо - нет валидации
public void processUserInput(String input) {
    // обработка без проверки
}

// Хорошо - с валидацией
public void processUserInput(String input) {
    if (input == null || input.trim().isEmpty()) {
        throw new IllegalArgumentException("Input cannot be null or empty");
    }
    
    if (input.length() > MAX_LENGTH) {
        throw new IllegalArgumentException("Input too long");
    }
    
    // проверка на SQL injection
    if (input.contains("'") || input.contains(";")) {
        throw new SecurityException("Invalid input characters");
    }
    
    // обработка
}
```

#### 2. Безопасная работа с паролями
```java
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;

public class PasswordUtils {
    private static final SecureRandom RANDOM = new SecureRandom();
    
    public static String hashPassword(String password, String salt) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(salt.getBytes());
            byte[] hashedPassword = md.digest(password.getBytes());
            return Base64.getEncoder().encodeToString(hashedPassword);
        } catch (Exception e) {
            throw new RuntimeException("Error hashing password", e);
        }
    }
    
    public static String generateSalt() {
        byte[] salt = new byte[16];
        RANDOM.nextBytes(salt);
        return Base64.getEncoder().encodeToString(salt);
    }
}
```

#### 3. Безопасная работа с SQL
```java
// Плохо - SQL injection
public User getUserById(String id) {
    String sql = "SELECT * FROM users WHERE id = " + id;
    // выполнение запроса
}

// Хорошо - PreparedStatement
public User getUserById(String id) {
    String sql = "SELECT * FROM users WHERE id = ?";
    try (PreparedStatement stmt = connection.prepareStatement(sql)) {
        stmt.setString(1, id);
        ResultSet rs = stmt.executeQuery();
        // обработка результата
    }
}
```

#### 4. Шифрование чувствительных данных
```java
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

public class EncryptionUtils {
    public static String encrypt(String data, SecretKey key) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] encryptedBytes = cipher.doFinal(data.getBytes());
        return Base64.getEncoder().encodeToString(encryptedBytes);
    }
    
    public static String decrypt(String encryptedData, SecretKey key) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedData));
        return new String(decryptedBytes);
    }
}
```

### Рекомендации по безопасности:
- **Регулярные обновления**: Использование последних версий библиотек
- **Логирование безопасности**: Отслеживание подозрительной активности
- **Принцип наименьших привилегий**: Минимальные права доступа
- **Защита от атак**: CSRF, XSS, SQL injection 