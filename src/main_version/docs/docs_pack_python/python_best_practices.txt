
РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Python Developer; ТЕМА: Основы лучших практик Python разработки

# Лучшие практики Python разработки для специалиста

## Введение в лучшие практики

### Определение лучших практик:
Лучшие практики Python разработки — это проверенные временем подходы, принципы и рекомендации, которые помогают писать качественный, поддерживаемый и эффективный код.

### Важность следования лучшим практикам:
- **Читаемость кода**: Понятность для других разработчиков
- **Поддерживаемость**: Легкость внесения изменений
- **Производительность**: Оптимальная работа приложений
- **Безопасность**: Защита от уязвимостей
- **Масштабируемость**: Возможность роста системы

### Основные принципы:
1. **SOLID принципы**: Основа объектно-ориентированного программирования
2. **DRY (Don't Repeat Yourself)**: Избежание дублирования кода
3. **KISS (Keep It Simple, Stupid)**: Простота решений
4. **YAGNI (You Aren't Gonna Need It)**: Не добавлять функциональность заранее
5. **PEP 8**: Стиль кодирования Python
6. **Zen of Python**: Философия Python

## Принципы SOLID

### Single Responsibility Principle (SRP):
**Класс должен иметь только одну причину для изменения**

#### Пример нарушения:
```python
class UserService:
    def create_user(self, user):
        # создание пользователя
        pass
    
    def send_email(self, to, subject):
        # отправка email
        pass
    
    def generate_report(self):
        # генерация отчета
        pass
```

#### Правильная реализация:
```python
class UserService:
    def create_user(self, user):
        # создание пользователя
        pass

class EmailService:
    def send_email(self, to, subject):
        # отправка email
        pass

class ReportService:
    def generate_report(self):
        # генерация отчета
        pass
```

### Open/Closed Principle (OCP):
**Программные сущности должны быть открыты для расширения, но закрыты для модификации**

#### Пример:
```python
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, payment):
        pass

class CreditCardProcessor(PaymentProcessor):
    def process_payment(self, payment):
        # обработка картой
        pass

class PayPalProcessor(PaymentProcessor):
    def process_payment(self, payment):
        # обработка PayPal
        pass
```


РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Python Developer; ТЕМА: Чистый код и соглашения по именованию

## Чистый код и соглашения по именованию

### Принципы чистого кода:

#### 1. Осмысленные имена
- **Переменные**: Описывают что содержат
- **Функции**: Описывают что делают
- **Классы**: Описывают что представляют

#### Примеры хороших имен:
```python
# Плохо
d = 30  # время в днях
l = []  # список пользователей

# Хорошо
days_since_creation = 30
active_users = []
```

#### 2. Функции должны быть маленькими
- **Максимум 20 строк**
- **Одна функция — одна задача**
- **Понятные имена функций**

#### Пример рефакторинга:
```python
# Плохо
def process_order(order):
    if order and order.items and len(order.items) > 0:
        for item in order.items:
            if item.price > 0:
                # 50+ строк логики
                pass

# Хорошо
def process_order(order):
    if not is_valid_order(order):
        return
    
    for item in order.items:
        process_item(item)

def is_valid_order(order):
    return order and order.items and len(order.items) > 0

def process_item(item):
    if item.price > 0:
        # логика обработки
        pass
```

### Соглашения по именованию в Python (PEP 8):

#### Классы:
- **PascalCase**: `UserService`, `PaymentProcessor`
- **Существительные**: `User`, `Order`, `EmailService`

#### Функции и переменные:
- **snake_case**: `get_user_by_id()`, `calculate_total()`
- **Глаголы для функций**: `create`, `update`, `delete`, `calculate`

#### Константы:
- **UPPER_SNAKE_CASE**: `MAX_RETRY_ATTEMPTS`, `DEFAULT_TIMEOUT`

#### Модули и пакеты:
- **snake_case**: `user_service.py`, `payment_processor.py`


РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Python Developer; ТЕМА: Паттерны проектирования в Python

## Паттерны проектирования в Python

### Классификация паттернов:

#### 1. Порождающие паттерны (Creational Patterns)

##### Singleton (Одиночка):
```python
class DatabaseConnection:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.connection_string = "database://localhost"
            self.initialized = True
```

##### Factory Method (Фабричный метод):
```python
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, payment):
        pass

class PaymentFactory:
    @staticmethod
    def create_processor(payment_type: str) -> PaymentProcessor:
        if payment_type == "credit_card":
            return CreditCardProcessor()
        elif payment_type == "paypal":
            return PayPalProcessor()
        else:
            raise ValueError(f"Unknown payment type: {payment_type}")
```

##### Builder (Строитель):
```python
class UserBuilder:
    def __init__(self):
        self.user = {}
    
    def set_name(self, name):
        self.user['name'] = name
        return self
    
    def set_email(self, email):
        self.user['email'] = email
        return self
    
    def set_age(self, age):
        self.user['age'] = age
        return self
    
    def build(self):
        return User(**self.user)

# Использование
user = UserBuilder().set_name("John").set_email("john@example.com").set_age(30).build()
```

#### 2. Структурные паттерны (Structural Patterns)

##### Adapter (Адаптер):
```python
class OldPaymentSystem:
    def make_payment(self, amount, currency):
        return f"Payment of {amount} {currency} processed"

class NewPaymentSystem:
    def process_payment(self, payment_data):
        return f"Payment processed: {payment_data}"

class PaymentAdapter:
    def __init__(self, new_system):
        self.new_system = new_system
    
    def make_payment(self, amount, currency):
        payment_data = {"amount": amount, "currency": currency}
        return self.new_system.process_payment(payment_data)
```


РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Python Developer; ТЕМА: Оптимизация производительности

## Оптимизация производительности

### Профилирование кода:

#### 1. Использование cProfile:
```python
import cProfile
import pstats

def slow_function():
    # медленная функция
    result = sum(i * i for i in range(1000000))
    return result

# Профилирование
profiler = cProfile.Profile()
profiler.enable()
slow_function()
profiler.disable()

# Анализ результатов
stats = pstats.Stats(profiler)
stats.sort_stats('cumulative')
stats.print_stats(10)
```

#### 2. Использование line_profiler:
```python
from line_profiler import LineProfiler

profiler = LineProfiler()
profiler.add_function(slow_function)
profiler.enable_by_count()
slow_function()
profiler.print_stats()
```

### Оптимизация памяти:

#### 1. Генераторы вместо списков:
```python
# Плохо - загружает весь список в память
def get_large_list():
    return [i * i for i in range(1000000)]

# Хорошо - генерирует значения по требованию
def get_large_generator():
    for i in range(1000000):
        yield i * i
```

#### 2. Использование __slots__:
```python
class User:
    __slots__ = ['name', 'email', 'age']
    
    def __init__(self, name, email, age):
        self.name = name
        self.email = email
        self.age = age
```

### Кэширование:

#### 1. Использование functools.lru_cache:
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

#### 2. Мемоизация с помощью декоратора:
```python
def memoize(func):
    cache = {}
    
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    
    return wrapper

@memoize
def expensive_calculation(n):
    # дорогостоящие вычисления
    return n * n
```

### Оптимизация циклов:

#### 1. Использование list comprehensions:
```python
# Плохо
squares = []
for i in range(1000):
    squares.append(i * i)

# Хорошо
squares = [i * i for i in range(1000)]
```

#### 2. Использование map и filter:
```python
# Плохо
filtered_numbers = []
for i in range(1000):
    if i % 2 == 0:
        filtered_numbers.append(i * i)

# Хорошо
filtered_numbers = list(map(lambda x: x * x, filter(lambda x: x % 2 == 0, range(1000))))
```


РОЛЬ: Specialist; СПЕЦИАЛЬНОСТЬ: Python Developer; ТЕМА: Безопасность в Python

## Безопасность в Python

### Валидация входных данных:

#### 1. Использование Pydantic:
```python
from pydantic import BaseModel, EmailStr, validator
from typing import Optional

class UserCreate(BaseModel):
    name: str
    email: EmailStr
    age: int
    
    @validator('age')
    def validate_age(cls, v):
        if v < 0 or v > 150:
            raise ValueError('Age must be between 0 and 150')
        return v
    
    @validator('name')
    def validate_name(cls, v):
        if len(v.strip()) < 2:
            raise ValueError('Name must be at least 2 characters')
        return v.strip()
```

#### 2. Санитизация данных:
```python
import html
import re

def sanitize_input(user_input: str) -> str:
    # Удаление HTML тегов
    clean_text = re.sub(r'<[^>]+>', '', user_input)
    # Экранирование специальных символов
    clean_text = html.escape(clean_text)
    return clean_text

def validate_email(email: str) -> bool:
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    return bool(re.match(pattern, email))
```

### Безопасная работа с паролями:

#### 1. Хеширование паролей:
```python
import bcrypt
import secrets

def hash_password(password: str) -> str:
    # Генерация соли
    salt = bcrypt.gensalt()
    # Хеширование пароля
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))

def generate_secure_token() -> str:
    return secrets.token_urlsafe(32)
```

#### 2. JWT токены:
```python
import jwt
from datetime import datetime, timedelta

SECRET_KEY = "your-secret-key"

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm="HS256")
    return encoded_jwt

def verify_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload
    except jwt.ExpiredSignatureError:
        raise ValueError("Token has expired")
    except jwt.JWTError:
        raise ValueError("Invalid token")
```

### Защита от SQL инъекций:

#### 1. Использование параметризованных запросов:
```python
import sqlite3

# Плохо - уязвимо к SQL инъекциям
def get_user_bad(user_id):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    query = f"SELECT * FROM users WHERE id = {user_id}"
    cursor.execute(query)
    return cursor.fetchone()

# Хорошо - безопасно
def get_user_good(user_id):
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    query = "SELECT * FROM users WHERE id = ?"
    cursor.execute(query, (user_id,))
    return cursor.fetchone()
```

#### 2. Использование ORM:
```python
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)
    email = Column(String)

# Безопасные запросы через ORM
def get_user_safe(user_id):
    session = Session()
    user = session.query(User).filter(User.id == user_id).first()
    session.close()
    return user
```

### Безопасная работа с файлами:

#### 1. Проверка путей файлов:
```python
import os
from pathlib import Path

def safe_file_operation(file_path: str):
    # Нормализация пути
    normalized_path = os.path.normpath(file_path)
    
    # Проверка на path traversal
    if '..' in normalized_path:
        raise ValueError("Path traversal detected")
    
    # Проверка расширения файла
    allowed_extensions = {'.txt', '.csv', '.json'}
    file_extension = Path(normalized_path).suffix
    
    if file_extension not in allowed_extensions:
        raise ValueError(f"File extension {file_extension} not allowed")
    
    # Безопасная работа с файлом
    with open(normalized_path, 'r') as file:
        return file.read()
```

### Логирование безопасности:

```python
import logging
from datetime import datetime

# Настройка логгера безопасности
security_logger = logging.getLogger('security')
security_logger.setLevel(logging.INFO)

def log_security_event(event_type: str, user_id: str, details: str):
    timestamp = datetime.utcnow().isoformat()
    log_message = f"[{timestamp}] {event_type} - User: {user_id} - {details}"
    security_logger.warning(log_message)

# Примеры использования
log_security_event("LOGIN_ATTEMPT", "user123", "Failed login attempt")
log_security_event("PERMISSION_DENIED", "user456", "Access denied to admin panel")
``` 